// lib/services/course_recommendation_service.dart

import 'dart:convert';
import 'dart:io';
import 'package:degreez/providers/course_provider.dart';
import 'package:flutter/material.dart';
import 'package:firebase_ai/firebase_ai.dart';
import '../models/course_recommendation_models.dart';
import '../services/ai/base_ai_service.dart';
import '../services/ai/ai_config.dart';
import '../services/ai/ai_utils.dart';
import 'optimization/ai_guided_hill_climbing_service.dart';
import 'optimization/candidate_validation_service.dart';

class CourseRecommendationService extends BaseAiService {
  static const String _systemInstruction = '''
${AiConfig.baseSystemInstruction}

You are a course recommendation specialist for academic planning. Your role is to help students select appropriate courses for a specific semester based on their academic history, major requirements, and catalog information.

Always follow this process:
1. Analyze the student's context (major, completed courses, semester, preferences)
2. Review the catalog PDF to understand available courses (if provided)
3. Identify potential courses that align with the student's needs
4. Create final recommendations totaling 15-18 credit points
5. Provide clear reasoning for each recommendation

Consider these factors:
- Prerequisites and academic progression
- Major requirements vs electives
- Course difficulty and student's academic level
- Schedule conflicts and workload balance
- Student's stated preferences and career goals

Respond with valid JSON only, following the exact schema provided.
the course name must be in hebrew.
''';

  CourseRecommendationService()
    : super(
        modelName: AiConfig.defaultModel,
        systemInstruction: _systemInstruction,
        generationConfig: AiUtils.createJsonConfig(
          _createRecommendationSchema(),
        ),
      );

  /// Main method to generate course recommendations
  Future<CourseRecommendationResponse> generateRecommendations(
    CourseRecommendationRequest request,
  ) async {
    try {
      // Parse actual year/semester based on display label like "Winter 2024-2025"
      final fallbackSemester = await CourseProvider()
          .getClosestAvailableSemester(request.semesterDisplayName);
      final parsed = CourseProvider().parseSemesterCode(fallbackSemester);
      debugPrint(
        'üü¢ Selected semester from UI: ${request.semesterDisplayName}',
      );
      debugPrint(
        'üîµ Using fallback semester for course data: $fallbackSemester',
      );
      debugPrint(
        'Parsed semester: $parsed for display name: $fallbackSemester',
      );
      if (parsed == null) {
        throw Exception(
          'Invalid semester display name: ${request.semesterDisplayName}',
        );
      }
      // Note: apiYear and semesterCode are available if needed for future use
      final (_, _) = parsed;
      
      // PHASE 1: Get 3 candidate course sets from AI
      debugPrint('üöÄ Phase 1: Generating 3 candidate course sets...');
      final multiSetResponse = await _identifyMultipleCandidateSets(request);
      debugPrint('‚úÖ Phase 1 complete: Generated ${multiSetResponse.courseSets.length} course sets');

      if (multiSetResponse.courseSets.isEmpty) {
        throw Exception('No course sets generated by AI');
      }

      // PHASE 2: Optimization algorithm (hill climbing) - placeholder for now
      debugPrint('üîß Phase 2: Running hill climbing optimization...');
      final optimizedSets = await _optimizeCourseSetsWithHillClimbing(
        multiSetResponse.courseSets,
        request,
      );
      debugPrint('‚úÖ Phase 2 complete: Optimized ${optimizedSets.length} course sets');

      // PHASE 3: AI chooses 2 final sets from optimized sets
      debugPrint('üß† Phase 3: AI selecting 2 final sets...');
      final finalRecommendations = await _chooseFinalTwoSets(
        optimizedSets,
        request,
      );
      debugPrint('‚úÖ Phase 3 complete: Selected 2 final course sets');

      return finalRecommendations;
    } catch (e) {
      debugPrint('Course recommendation error: $e');
      throw Exception('Failed to generate course recommendations: $e');
    }
  }

  /// Step 1: Use structured JSON response to identify 3 candidate course sets
  Future<MultiSetCandidateResponse> _identifyMultipleCandidateSets(
    CourseRecommendationRequest request,
  ) async {
    // Create model for multiple candidate course sets identification
    final candidateModel = FirebaseAI.googleAI().generativeModel(
      model: AiConfig.defaultModel,
      systemInstruction: Content.text(_systemInstruction),
      generationConfig: AiUtils.createJsonConfig(_createMultiSetCandidateSchema()),
    );

    // Prepare the prompt for 3 sets
    String prompt = '''
Please identify 3 different sets of candidate courses for the following student:

${request.userContext}

Target Semester: ${request.semesterDisplayName}

Requirements:
- Generate exactly 3 diverse course sets
- Each set should contain 5-7 courses totaling 15-18 credit points
- All course names must be in Hebrew
- Each set should represent a different strategic approach (e.g., core-focused, elective-heavy, prerequisite-clearing, etc.)
- Consider the student's academic level, major, and completed courses
- Ensure courses are likely available in the specified semester
- Provide brief reasoning for each set's strategy

Return your response as valid JSON with the required schema.
Each course must have both courseId (course number) and courseName (Hebrew name).
''';

    // Generate response with or without catalog PDF
    final response = await _generateWithOptionalPdf(
      candidateModel,
      prompt,
      request.catalogFilePath,
    );

    try {
      final jsonData = jsonDecode(response.text ?? '{}');
      return MultiSetCandidateResponse.fromJson(jsonData);
    } catch (e) {
      throw Exception('Failed to parse multiple candidate sets response: $e');
    }
  }







  /// PHASE 2: AI-Guided Hill Climbing Optimization Algorithm
  Future<List<CourseSet>> _optimizeCourseSetsWithHillClimbing(
    List<CourseSet> initialSets,
    CourseRecommendationRequest request,
  ) async {
    debugPrint('üîß Starting AI-guided hill climbing optimization...');
    
    try {
      // Step 1: Get valid candidates for optimization
      debugPrint('üîç Step 1: Fetching valid candidates...');
      final validationService = CandidateValidationService();
      final validCandidates = await validationService.getValidCandidates(request);
      debugPrint('‚úÖ Found ${validCandidates.length} valid candidates');
      
      // Step 2: Run AI-guided hill climbing optimization
      debugPrint('üß† Step 2: Running AI-guided hill climbing...');
      final hillClimbingService = AiGuidedHillClimbingService();
      final optimizedSets = await hillClimbingService.optimize(
        initialSets: initialSets,
        validCandidates: validCandidates,
        request: request,
        maxIterations: 5, // Increased iterations for better optimization
      );
      
      debugPrint('‚úÖ AI-guided hill climbing optimization complete');
      return optimizedSets;
      
    } catch (e) {
      debugPrint('‚ùå Error during hill climbing optimization: $e');
      debugPrint('üîÑ Falling back to original sets');
      return initialSets; // Fallback to original sets if optimization fails
    }
  }

  /// PHASE 3: AI chooses 2 final sets from optimized sets
  Future<CourseRecommendationResponse> _chooseFinalTwoSets(
    List<CourseSet> optimizedSets,
    CourseRecommendationRequest request,
  ) async {
    // Create model for final set selection
    final finalSelectionModel = FirebaseAI.googleAI().generativeModel(
      model: AiConfig.defaultModel,
      systemInstruction: Content.text(_systemInstruction),
      generationConfig: AiUtils.createJsonConfig(_createFinalSelectionSchema()),
    );

    // Prepare the prompt for final selection
    String prompt = '''
You have been given 3 optimized course sets from a hill climbing algorithm. 
Please analyze all sets and choose the best 2 sets for the following student:

STUDENT CONTEXT:
${request.userContext}

TARGET SEMESTER: ${request.semesterDisplayName}

OPTIMIZED COURSE SETS:
${jsonEncode(optimizedSets.map((set) => set.toJson()).toList())}

REQUIREMENTS:
- Choose exactly 2 sets that best serve the student
- Each chosen set should offer a different strategic approach
- Provide detailed reasoning for why each set was chosen
- Consider the student's preferences, academic level, and degree progression
- Explain the differences between the two chosen sets

Return your response as valid JSON with the required schema.
''';

    final response = await _generateWithOptionalPdf(
      finalSelectionModel,
      prompt,
      request.catalogFilePath,
    );

    try {
      final jsonData = jsonDecode(response.text ?? '{}');
      
      // Convert the response to our existing CourseRecommendationResponse format
      final selectedSets = jsonData['selectedSets'] as List;
      final allRecommendations = <CourseRecommendation>[];
      
      // Convert both sets to recommendations with different priorities
      for (int setIndex = 0; setIndex < selectedSets.length; setIndex++) {
        final set = selectedSets[setIndex];
        final courses = set['courses'] as List;
        
        for (final course in courses) {
          allRecommendations.add(CourseRecommendation(
            courseId: course['courseId'],
            courseName: course['courseName'],
            creditPoints: (course['creditPoints'] as num?)?.toDouble() ?? 3.0,
            reason: set['reasoning'] ?? 'Selected by AI',
            priority: setIndex + 1, // Set 1 gets priority 1, Set 2 gets priority 2
            category: 'Set ${setIndex + 1}',
          ));
        }
      }
      
      return CourseRecommendationResponse(
        recommendations: allRecommendations,
        totalCreditPoints: allRecommendations.fold(0.0, (sum, rec) => sum + rec.creditPoints),
        summary: jsonData['summary'] ?? 'AI selected 2 optimal course sets',
        reasoning: jsonData['overallReasoning'] ?? 'Selected based on student preferences',
        generatedAt: DateTime.now(),
        originalRequest: request,
      );
    } catch (e) {
      throw Exception('Failed to parse final set selection response: $e');
    }
  }

  /// Helper method to generate content with optional PDF
  Future<GenerateContentResponse> _generateWithOptionalPdf(
    GenerativeModel model,
    String prompt,
    String? catalogFilePath,
  ) async {
    if (catalogFilePath != null && catalogFilePath.isNotEmpty) {
      final catalogFile = File(catalogFilePath);

      // Validate file before processing
      if (!await AiUtils.validateFileSize(catalogFile)) {
        throw Exception(AiUtils.getFileSizeErrorMessage());
      }

      if (!await AiUtils.validatePdfFormat(catalogFile)) {
        throw Exception('Invalid PDF file format');
      }

      final catalogBytes = await catalogFile.readAsBytes();
      return await model.generateContent([
        AiUtils.createPdfContent(prompt, catalogBytes),
      ]);
    } else {
      return await model.generateContent([Content.text(prompt)]);
    }
  }

  /// NEW: Schema for 3 candidate course sets
  static Schema _createMultiSetCandidateSchema() {
    return Schema.object(
      properties: {
        'courseSets': Schema.array(
          items: Schema.object(
            properties: {
              'courses': Schema.array(
                items: Schema.object(
                  properties: {
                    'id': Schema.string(description: 'Course ID/Number'),
                    'name': Schema.string(description: 'Course name in Hebrew'),
                  },
                ),
                description: '5-7 courses totaling 15-18 credit points',
              ),
              'totalCredits': Schema.number(
                description: 'Total credit points for this set (15-18)',
              ),
              'reasoning': Schema.string(
                description: 'Strategy reasoning for this specific set in a few words',
              ),
            },
          ),
          description: 'Array of exactly 3 diverse course sets',
        ),
        'overallReasoning': Schema.string(
          description: 'Overall explanation of the 3 different strategies used in a few words',
        ),
      },
    );
  }

  /// Schema for final recommendations
  static Schema _createRecommendationSchema() {
    return Schema.object(
      properties: {
        'recommendations': Schema.array(
          items: Schema.object(
            properties: {
              'courseId': Schema.string(),
              'courseName': Schema.string(),
              'creditPoints': Schema.number(),
              'reason': Schema.string(
                description: 'Why this course is recommended',
              ),
              'priority': Schema.integer(
                description: 'Priority 1-5 (1=highest)',
              ),
              'category': Schema.string(
                description: 'e.g., Core, Elective, Prerequisites',
              ),
            },
          ),
          description:
              'List of recommended courses (target 15-18 total credit points)',
        ),
        'totalCreditPoints': Schema.number(),
        'summary': Schema.string(
          description: 'Brief summary of the recommendation set',
        ),
        'reasoning': Schema.string(
          description: 'Overall reasoning for the recommendation strategy',
        ),
      },
    );
  }

  /// Schema for final set selection (AI chooses 2 from 3)
  static Schema _createFinalSelectionSchema() {
    return Schema.object(
      properties: {
        'selectedSets': Schema.array(
          items: Schema.object(
            properties: {
              'setId': Schema.number(description: 'Original set ID (0-2)'),
              'strategy': Schema.string(description: 'Strategy name for this set'),
              'reasoning': Schema.string(description: 'Why this set was chosen'),
              'courses': Schema.array(
                items: Schema.object(
                  properties: {
                    'courseId': Schema.string(description: 'Course ID/number'),
                    'courseName': Schema.string(description: 'Course name in Hebrew'),
                    'creditPoints': Schema.number(description: 'Credit points for this course'),
                  },
                ),
                description: 'Courses in this selected set',
              ),
              'totalCredits': Schema.number(description: 'Total credits for this set'),
            },
          ),
          description: 'Exactly 2 selected course sets',
        ),
        'summary': Schema.string(description: 'Brief summary of the selection'),
        'overallReasoning': Schema.string(description: 'Overall reasoning for choosing these 2 sets'),
        'comparison': Schema.string(description: 'How the 2 sets differ and complement each other'),
      },
    );
  }

  /// Interactive feedback processing method
  Future<FeedbackResponse> processFeedback(
    FeedbackProcessingRequest request,
  ) async {
    final session = request.session;
    final feedback = request.feedback;

    // Create model for feedback processing with function calling
    final feedbackModel = FirebaseAI.googleAI().generativeModel(
      model: AiConfig.defaultModel,
      systemInstruction: Content.text(_getFeedbackSystemInstruction()),
      generationConfig: AiUtils.createJsonConfig(_createFeedbackResponseSchema()),
    );

    // Prepare conversation context for the AI
    final conversationContext = _buildConversationContext(session);
    final currentRecommendationsJson = session.currentRecommendations
        ?.map((set) => set.toJson())
        .toList();

    final prompt = '''
You are an intelligent course recommendation assistant. A student has provided feedback on their course recommendations. Your task is to analyze this feedback and intelligently modify the course sets to better meet their needs.

IMPORTANT: You must maintain the multi-stage optimization approach:
1. Keep the academic logic and constraints in mind
2. Ensure course availability and prerequisites are respected  
3. Maintain 15-18 credit balance per set
4. Consider the student's academic progression

ORIGINAL CONTEXT:
${session.originalRequest.userContext}

SEMESTER: ${session.originalRequest.semesterDisplayName}

CONVERSATION HISTORY:
$conversationContext

CURRENT COURSE SETS:
${jsonEncode(currentRecommendationsJson)}

USER FEEDBACK:
Type: ${feedback.type.name}
Message: "${feedback.message}"
${feedback.courseId != null ? 'Specific Course: ${feedback.courseId}' : ''}
${feedback.setId != null ? 'Specific Set: ${feedback.setId}' : ''}

ANALYSIS TASK:
Based on this feedback, intelligently modify the course sets. Consider:

1. **If LIKE feedback**: Understand what they liked and emphasize similar characteristics
2. **If DISLIKE feedback**: Identify what they disliked and find alternatives
3. **If REPLACE feedback**: Find suitable replacement courses that maintain academic logic
4. **If MODIFY feedback**: Adjust the sets according to their specific requests
5. **If GENERAL feedback**: Use your judgment to improve based on their comments

REQUIREMENTS:
- Return exactly 2 updated course sets
- Each set should have 5-7 courses totaling 15-18 credits
- All course names must be in Hebrew
- Provide clear reasoning for changes made
- Maintain academic progression logic
- Consider course availability in the specified semester

Respond with valid JSON following the schema. Focus on creating sets that address the user's feedback while maintaining educational value.
''';

    final response = await feedbackModel.generateContent([
      Content.text(prompt),
    ]);

    return _parseFeedbackResponse(response.text ?? '{}');
  }

  /// Build conversation context string for AI
  String _buildConversationContext(RecommendationSession session) {
    final buffer = StringBuffer();
    
    for (final message in session.conversation) {
      final role = message.isUser ? 'USER' : 'ASSISTANT';
      buffer.writeln('$role: ${message.content}');
      
      if (message.feedback != null) {
        final feedback = message.feedback!;
        buffer.writeln('  - Feedback Type: ${feedback.type.name}');
        buffer.writeln('  - Message: ${feedback.message}');
        if (feedback.courseId != null) {
          buffer.writeln('  - Course ID: ${feedback.courseId}');
        }
        if (feedback.setId != null) {
          buffer.writeln('  - Set ID: ${feedback.setId}');
        }
      }
      
      if (message.recommendations != null) {
        buffer.writeln('  - Provided ${message.recommendations!.length} course sets');
      }
      
      buffer.writeln();
    }
    
    return buffer.toString();
  }

  /// Get system instruction for feedback processing
  String _getFeedbackSystemInstruction() {
    return '''
You are an intelligent course recommendation assistant that can process user feedback and adjust recommendations accordingly.

Your capabilities:
1. Analyze user feedback (likes, dislikes, specific requests)
2. Modify course recommendations based on feedback
3. Explain your reasoning clearly

Guidelines:
- Always maintain academic logic (prerequisites, progression, credit balance)
- Consider user preferences while ensuring degree requirements are met
- Be transparent about what changes you made and why
- Always return exactly 2 updated course sets
- Prioritize user satisfaction while maintaining academic validity

Your responses must be in valid JSON format with the specified schema.
''';
  }

  /// Create JSON schema for feedback responses
  Schema _createFeedbackResponseSchema() {
    return Schema.object(
      properties: {
        'updatedRecommendations': Schema.array(
          items: Schema.object(
            properties: {
              'setId': Schema.integer(),
              'courses': Schema.array(
                items: Schema.object(
                  properties: {
                    'id': Schema.string(),
                    'name': Schema.string(),
                  },
                ),
              ),
              'totalCredits': Schema.number(),
              'reasoning': Schema.string(),
            },
          ),
        ),
        'explanation': Schema.string(),
        'usedAlgorithm': Schema.boolean(),
        'fetchedNewData': Schema.boolean(),
      },
    );
  }



  /// Parse feedback response from AI
  FeedbackResponse _parseFeedbackResponse(String responseText) {
    try {
      final jsonData = jsonDecode(responseText);
      
      return FeedbackResponse.fromJson(jsonData);
    } catch (e) {
      debugPrint('Failed to parse feedback response: $e');
      
      // Return default response if parsing fails
      return const FeedbackResponse(
        updatedRecommendations: [],
        explanation: 'Sorry, I encountered an error processing your feedback. Please try again.',
        usedAlgorithm: false,
        fetchedNewData: false,
      );
    }
  }

}
